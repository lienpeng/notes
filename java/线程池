ThreadPoolExecutor executor = new ThreadPoolExecutor(
        10,//核心线程数
        20,//最大线程数
        5,//非核心回收超时时间
        TimeUnit.SECONDS,//超时时间单位
        new ArrayBlockingQueue<>(30)//任务队列);

10个任务，执行1秒
20个任务 2秒
40个任务 4秒 10+10+10+10
41个任务 4秒 11+11+11+8
45个任务 3秒 15+15+15

原理 任务数大于 核心线程数+队列数 时，工作线程=任务数-核心线程数
当然 任务数大于 最大线程数+任务队列数 时，多的任务默认会丢弃


1、定长线程池（FixedThreadPool）

特点：只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。
应用场景：控制线程最大并发数

2、定时线程池（ScheduledThreadPool ）

特点：核心线程数量固定，非核心线程数量无限，执行完闲置10ms后回收，任务队列为延时阻塞队列。
应用场景：执行定时或周期性的任务。

3、可缓存线程池（CachedThreadPool）

特点：无核心线程，非核心线程数量无限，执行完闲置60s后回收，任务队列为不存储元素的阻塞队列。
应用场景：执行大量、耗时少的任务。

4、单线程化线程池（SingleThreadExecutor）

特点：只有1个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。
应用场景：不适合并发但可能引起IO阻塞性及影响UI线程响应的操作，如数据库操作、文件操作等。

上述四个线程池虽然方便，但是阿里巴巴规范明确说明不建议使用，因为可能会造成内存溢出，具体原因如下：

FixedThreadPool和SingleThreadExecutor：主要问题是堆积的请求处理队列均采用LinkedBlockingQueue，可能会耗费非常大的内存，严重的直接导致内存溢出。
CachedThreadPool和ScheduledThreadPool：主要问题是它们的最大线程数是Integer.MAX_VALUE，可能会创建数量非常多的线程，严重的直接导致内存溢出。
 